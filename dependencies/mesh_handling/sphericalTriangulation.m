function [STri] = sphericalTriangulation(varargin)
%SPHERICALTRIANGULATION Creates a triangulation of a sphere with given
%radius centered at {X,Y,Z} = {0,0,0} in 3D.  Can also be used to create a
%triangulation of a spherical cap with boundary in the plane Z=0
%   Detailed explanation goes here

%==========================================================================
% Process input parameters
%==========================================================================

% Default parameters ------------------------------------------------------
radius = 1; % The unit sphere
numIterations = 3; % N iterations yields 8*(4^N) faces
capFlag = false; % If true the program will create a spherical cap
theta = pi/2;

% Parse user input --------------------------------------------------------
for i = 1:length(varargin)
    if isa(varargin{i}, 'double')
        continue;
    end
    if isa(varargin{i}, 'logical')
        continue;
    end
    if ~isempty(regexp(varargin{i}, '^[Rr]adius', 'match'))
        radius = varargin{i+1};
    end
    if ~isempty(regexp(varargin{i}, '^[Nn]um[Ii]terations', 'match'))
        numIterations = varargin{i+1};
    end
    if ~isempty(regexp(varargin{i}, '^[Mm]ake[Cc]ap', 'match'))
        capFlag = varargin{i+1};
    end
    if ~isempty(regexp(varargin{i}, '^[Tt]heta', 'match'))
        theta = wrapTo2Pi( varargin{i+1} );
        if ~capFlag
            warning('Spherical cap creation is NOT enabled!');
        end
    end
end

%==========================================================================
% Create initial triangulation
%==========================================================================
% Full triangulation is generated by subdividing the faces of a regular
% octahedron --------------------------------------------------------------

% Basis vector for defining the vertices of the initial octahedron --------
A = [1,0,0]*radius;
B = [0,1,0]*radius;
C = [0,0,1]*radius;

% In order to vectorize the code we use 'ABC' format for the triangulation.
% Each of the following objects is an (Nfx3) array holding the (A,B,C) ----
% -point of each face, respectively.  This will be illustrated below. -----
Apoints = [ A; A; -A; -A; -A; -A; A; A ];
Bpoints = [ B; B; B; B; -B; -B; -B; -B ];
Cpoints = [ C; -C; C; -C; C; -C; C; -C ];

%==========================================================================
% Iteratively subdivide the faces to create refined triangulation
%==========================================================================
%
%        ^ C          Each face will be subdivided into four faces
%       / \           [ A; AB/2; AC/2;      1st face
% AC/2 /_4_\ CB/2       AB/2; B; CB/2;      2nd face
%     /\ 3 /\           AC/2; AB/2; CB/2;   3rd face
%    / 1\ /2 \          AC/2; CB/2; C ]     4th face
% A /____V____\ B
%       AB/2
%
%==========================================================================

for iteration = 1:numIterations
   
   % Create new vertices and normalize to the proper radius ---------------
   AB_2 = (Apoints+Bpoints)/2;
   AB_2 = ( AB_2 ./ sqrt(sum(AB_2.^2,2)) ) * radius;
   
   AC_2 = (Apoints+Cpoints)/2;
   AC_2 = ( AC_2 ./ sqrt(sum(AC_2.^2,2)) ) * radius;
   
   CB_2 = (Cpoints+Bpoints)/2;
   CB_2 = ( CB_2 ./ sqrt(sum(CB_2.^2,2)) ) * radius;
   
   % Add the new points to the triangulation vertex list ------------------
   Apoints = [ Apoints; AB_2; AC_2; AC_2 ];
   Bpoints = [ AB_2; Bpoints; AB_2; CB_2 ];
   Cpoints = [ AC_2; CB_2; CB_2; Cpoints ];
   
end

%==========================================================================
% Convert 'ABC' format to vertex/connectivity list for output
%==========================================================================

ABCpoints = [ Apoints; Bpoints; Cpoints ];
vertex = unique( ABCpoints, 'rows' ); % triangulation vertex list ---------

% Associate a vertex ID to each entry in the 'ABC' list -------------------
[~, A_ID] = ismember( Apoints, vertex, 'rows' );
[~, B_ID] = ismember( Bpoints, vertex, 'rows' );
[~, C_ID] = ismember( Cpoints, vertex, 'rows' );

faces = [ A_ID, B_ID, C_ID ]; % triangulation connectivity list -----------

%==========================================================================
% Create spherical cap based on user input
%==========================================================================

if capFlag
   
    if numel(theta) == 1
        
        % The minimum value of Z that will be retained in the
        % spherical cap
        Zmin = fix( cos( theta ) * 10^6 ) / 10^6;
        
        % Find all vertices with Z-values < Zmin
        rm_ID = find(vertex(:,3) < Zmin);
        
    elseif numel(theta) == 2
        
        % The minimum/maximum values of Z that will be retained in the
        % in the spherical band
        Zlim = fix( cos(theta) * 10^6 ) / 10^6;
        
        % Find all vertices not in the range Zmin < Z < Zmax
        rm_ID = find((vertex(:,3) < Zlim(2)) | (vertex(:,3) > Zlim(1)));
        
    end
   
   % Update vertex and face list ------------------------------------------  
   % Remove vertices at specified index values
   newVertex = vertex;
   newVertex( rm_ID, : ) = [];
   
   % Find the new index for each of the new vertices
   [~, newVertexIndex] = ismember(vertex, newVertex, 'rows');
   
   % Find any faces that used the invalid vertices and remove them
   newFaceList = faces;
   want(1,1,:) = rm_ID;
   row_v = any(any(bsxfun(@eq, newFaceList, want),2),3);
   newFaceList( row_v, : ) = [];
   
   % Now update the vertex indices to the new ones
   newFaceList = newVertexIndex(newFaceList);
   
   vertex = newVertex;
   faces = newFaceList;
   
   % Translate cap boundary to lie in the Z=0 plane ------------------------
   vertex = [ vertex(:,1), vertex(:,2), ...
      vertex(:,3) - min(vertex(:,3)) ];
   
end

%==========================================================================
% Finalize output
%==========================================================================

STri = triangulation( faces, vertex );

end

